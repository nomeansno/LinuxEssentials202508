# Prozesse

## Übung 1: Prozesse anzeigen
- Zeige die laufenden Prozesse in der aktuellen Shell an. 
- Verwende dazu `ps` ohne Optionen
- Starte anschließend eine weitere Shell mit dem Kommando `bash`. 
- Führe das Kommando `ps` erneut aus. Welches ist die *Eltern-* und welches die *Kind-*Shell? Woran kann man das erkennen?

## Übung 2: Alle Prozesse anzeigen
Zeige **alle** laufenden Prozesse auf deinem System an.
- Verwende `ps aux` um alle Prozesse zu sehen
- Nutze `ps -ef` für eine andere Darstellung
- Was ist der Unterschied? Vielleicht hilft es, dir hier die Spaltennamen anzeigen zu lassen. Versuche es mit einer Pipe und `head`.
- Probiere `pstree` für eine Baumansicht (dazu musst du ggf. das Paket `psmisc` installieren)

## Übung 3: Prozesse nach Ressourcenverbrauch sortieren
Finde die Prozesse, die am meisten CPU und RAM verbrauchen.
- Starte `top`
- Sortiere nach CPU-Verbrauch (Taste 'P' (großes 'P') in `top`)
- Sortiere nach RAM-Verbrauch (Taste 'M' (großes 'M') in `top`)

## Übung 4: Prozess in den Hintergrund schicken
Starte einen Prozess, der lange läuft, z.B. mit `sleep`:
```bash
sleep 300
```
> [!NOTE]
> Das Kommando `sleep` macht einfach gar nichts für die Anzahl der Sekunden, die wir angeben. Wird z.B. in Skripten benutzt um ein wenig zu warten, dass eine bestimmte Aufgabe erfüllt wurde.

Du kannst nun keine Kommandos mehr ausführen, da du in einer Shell nur einen einzelnen Prozess im **Vordergrund** ausführen kannst. Du hast nun entweder die Möglichkeit, diesen Prozess zu beenden, oder ihn in den Hintergrund zu schicken. Wir probieren letzteres:
- Drücke nun die Tastenkombination `STRG z`
- Du kannst wieder Eingaben machen, yeah! Aber was ist mit dem Prozess passiert? Du solltest eine Ausgabe sehen wie:
```bash
[1]+  Stopped                 sleep 300
```
Der Prozess wurde in den Hintergrund geschickt **und** angehalten/gestoppt. Du kannst dir mit dem Kommando `jobs` alle sich im Hintergrund befindlichen Prozesse und deren Status anzeigen lassen.

Hole den Prozess nun mit dem Kommando `fg` wieder in den Forgergrund und starte ihn damit gleichzeit wieder.

Nutze erneut `STRG z` um den Prozess in den Hintergrund zu schicken (starte ggf. einen neuen), gib dann `bg` ein um den Prozess im Hintergrund fortzusetzen und prüfe das Ergebnis mit `jobs`

## Übung 5: Prozess im Hintergrund starten
Wir können Prozesse auch direkt nach dem Start in den Hintergrund schicken und starten, in dem wir ein `&` ans Ende der Eingabe setzen:
```bash
sleep 300 &
ping google.com &
```
- Liste alle Background-Jobs mit `jobs`
- Bringe nun `ping` wieder in den Vordergrund mit `fg`. Dazu musst du `fg` den Index von `ping` übergeben

> [!NOTE]
> Wir das Zeichen `&` ja schon von den Redirects zur Angabe einer Kanalnummer bzw. Filedescriptors. In diesem Fall hat es jedoch eine andere Bedeutung, es ist ein Shell-Operator, der das Kommando im Hintergrund ausführt. Es gibt hier keinen Zusammenhang, genauso wie das `*` in der Shell einmal eine Wildcard ist und in der Mathematik das Zeichen für die Multiplikation.

## Übung 6: Prozess-IDs finden
Finde die PID verschiedener Prozesse.

Öffne zwei Terminals und starte in einem das Kommando `sleep 300`, schicke den Prozess mit `STRG z` in den Hintergrund und starte ihn dort wieder mit `bg`. Der Prozess läuft nun im Hintergrund weiter. 
Versuche nun, diesen Prozess aus dem anderen Terminal heraus zu beenden. Dafür musst du mit `kill` ein bestimmtes Signal an diesen Prozess senden. `kill` akzeptiert aber nur PIDs und keine Kommandos als Argument.
- Verwende `ps -ef | grep sleep` um die PID des Prozesses zu ermitteln
- Beende den Prozess mit `kill` und der Angabe der PID
- Prüfe anschliessend mit `jobs` den Status des Prozesses
- Informiere dich in der Manpage von `kill`, welches Signal an diesen Prozess gesendet wurde
- Schau dir die Liste aller Signale mit dem Kommando `kill -l` an. Wichtig sind vielleicht folgende Signale:
  - `1) SIGHUP`
  - `2) SIGINT`
  - `3) SIGQUIT`
  - `9) SIGKILL`
  - `15) SIGTERM`
  - `18) SIGCONT`
  - `19) SIGSTOP`

Starte einen neuen Prozess `sleep 1200` und schicke ihn in den Hintergrund mit `STRG z`. Prüfe den Status mit `jobs`. Der Prozess ist angehalten. 
- Versuche nun, diesen Prozess mit dem Kommando `kill` und dem entsprechenden Signal im Hintergrund wieder auszuführen. Prüfe das ganze mit `jobs`.
- Mit `kill` können Signale auf mehrere Arten gesendet werden: Über die Angabe der Signalnummer, des Namens, mit Option, ohne Option. Wie verschiedenen Möglichkeiten findest du?
- Halte den Prozess nun an. Auch wieder mit `kill` und dem entsprechenden Signal
- Brich den Prozess nun hart ab - töte ihn!

Informiere dich über den Unterschied von z.B. `SIGTERM` und `SIGINT` zu `SIGKILL`.

## Übung 7: Prozesse beenden
Starte drei `sleep 1000 &` Prozesse im Hintergrund.

Nutze nun das Kommando `pkill`, welchem nicht eine PID, sondern ein Name bzw. Pattern übergeben werden kann. Was passiert, wenn du `pkill sleep` ausführst?

## Übung 8: Prozess-Signale und Tastenkombinationen
Bestimmte Tastenkombinationen senden im Endeffekt nur Signale an den momentan aktiven Prozess. Versuche herauszufinden, welche Signale die Tastenkombinationen `STRG z` und `STRG c` senden.

Versuche, anstatt der Tastenkombination das entsprechende Signal mit `kill` an einen Prozess zu senden.

